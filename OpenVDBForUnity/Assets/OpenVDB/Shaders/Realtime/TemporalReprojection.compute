// TemporalReprojection.compute
// Reprojects the previous frame's volume rendering result to the current frame.
// This allows amortizing ray march cost across multiple frames.
#pragma kernel TemporalReproject

// Current frame result (from ray march pass, possibly with fewer samples)
Texture2D<float4> _CurrentColor;
Texture2D<float> _CurrentDepth;

// Previous frame history
Texture2D<float4> _HistoryColor;
Texture2D<float> _HistoryDepth;

// Motion vectors (from Unity)
Texture2D<float2> _MotionVectors;

// Output
RWTexture2D<float4> _OutputColor;
RWTexture2D<float> _OutputDepth;

// Parameters
float2 _Resolution;
float _BlendFactor;        // 0.05 = 95% history, 5% current
float _DepthRejectThreshold;
float _ColorBoxScale;      // For neighborhood clamping (1.0 = tight, 2.0 = loose)
float4x4 _PrevViewProj;
float4x4 _CurrInvViewProj;

float2 ClampUV(float2 uv)
{
    return clamp(uv, 0.5 / _Resolution, 1.0 - 0.5 / _Resolution);
}

// AABB clamp for color neighborhood (avoids ghosting)
float4 ClampToNeighborhood(float4 color, float4 minColor, float4 maxColor)
{
    return clamp(color, minColor, maxColor);
}

[numthreads(8, 8, 1)]
void TemporalReproject(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= (uint2)_Resolution))
        return;

    float2 uv = (float2(id.xy) + 0.5) / _Resolution;

    // Current frame data
    float4 currentColor = _CurrentColor[id.xy];
    float currentDepth = _CurrentDepth[id.xy];

    // Get motion vector for reprojection
    float2 motionVector = _MotionVectors[id.xy];
    float2 historyUV = uv - motionVector;

    // Check if reprojected UV is valid
    if (any(historyUV < 0.0) || any(historyUV > 1.0))
    {
        _OutputColor[id.xy] = currentColor;
        _OutputDepth[id.xy] = currentDepth;
        return;
    }

    // Sample history
    uint2 historyPixel = uint2(historyUV * _Resolution);
    historyPixel = clamp(historyPixel, uint2(0, 0), uint2(_Resolution) - 1);
    float4 historyColor = _HistoryColor[historyPixel];
    float historyDepth = _HistoryDepth[historyPixel];

    // Neighborhood clamping (3x3) to reject ghosting
    float4 minColor = currentColor;
    float4 maxColor = currentColor;

    for (int dy = -1; dy <= 1; dy++)
    {
        for (int dx = -1; dx <= 1; dx++)
        {
            int2 neighborPixel = int2(id.xy) + int2(dx, dy);
            neighborPixel = clamp(neighborPixel, int2(0, 0), int2(_Resolution) - 1);
            float4 neighborColor = _CurrentColor[neighborPixel];
            minColor = min(minColor, neighborColor);
            maxColor = max(maxColor, neighborColor);
        }
    }

    // Expand the clamp box slightly to allow some temporal accumulation
    float4 colorCenter = (minColor + maxColor) * 0.5;
    float4 colorExtent = (maxColor - minColor) * 0.5 * _ColorBoxScale;
    minColor = colorCenter - colorExtent;
    maxColor = colorCenter + colorExtent;

    // Clamp history to neighborhood
    historyColor = ClampToNeighborhood(historyColor, minColor, maxColor);

    // Depth rejection: if depth difference is too large, use current frame only
    float depthDiff = abs(currentDepth - historyDepth);
    float depthWeight = depthDiff < _DepthRejectThreshold ? 1.0 : 0.0;

    // Blend
    float blend = lerp(1.0, _BlendFactor, depthWeight);
    float4 result = lerp(historyColor, currentColor, blend);

    _OutputColor[id.xy] = result;
    _OutputDepth[id.xy] = lerp(historyDepth, currentDepth, blend);
}
